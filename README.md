# Це **фінальний проєкт з алгоритмів та структур даних**. Нижче — короткий опис рішень для завдань **1–7**.

---

## Завдання 1: Однозв’язний список: реверс, сортування, злиття

### Зроблено

- `reverse()` — реверсування in-place (перелінковування `next`).
- `merge_sort(head)` — сортування злиттям; допоміжні `get_middle()` і `sorted_merge(a, b)`.
- `merge_sorted_lists(list1, list2)` — злиття двох відсортованих списків у відсортований.

### Складність

- `reverse`: `O(n)` час, `O(1)` пам’ять  
- `merge_sort`: `O(n log n)` час, `O(log n)` стек  
- `merge_sorted_lists`: `O(n+m)`

### Висновок 

Реалізовано базові операції з однозв’язним списком: реверс (in-place), сортування злиттям та злиття двох відсортованих списків.  
Алгоритми працюють коректно на крайових випадках (порожній список, 1 елемент, дублікати), не витрачають зайву пам’ять поза необхідною рекурсією під час `merge_sort`.  
Складність відповідає теорії: `reverse` — `O(n)` часу та `O(1)` пам’яті; `merge_sort` — `O(n log n)` часу і `O(log n)` стеку; `merge_sorted_lists` — `O(n+m)`.  
Таким чином, модуль забезпечує ефективну основу для подальших операцій над списками та масштабування на великі дані.



## Завдання 2: Дерево Піфагора (turtle + рекурсія)

### Опис
Рекурсивна побудова **дерева Піфагора**: кожна гілка зменшується у `√2/2` разів і розгалужується під кутами **±45°**.  
Рівень рекурсії задається користувачем. Є варіант з **автомасштабом крони** під розмір вікна та **покроковою анімацією**.

### Що реалізовано

- Рекурсія: `pythagoras_tree(...)` (база `level == 0`).
- Автомасштаб: довжина **першої гілки** підбирається так, щоб крона займала ~80% висоти вікна.
- Короткий стовбур (частка від першої гілки) + старт нижче центра кадру.
- Опційна **покрокова анімація** з паузою між сегментами.
- Інтерактивне введення `level` з валідацією.

### Параметри 

- level — глибина рекурсії (рекомендовано 8–12).
- canopy_ratio — частка висоти вікна під крону (типово 0.80).
-trunk_length — довжина стовбура (як частка від першої гілки, напр. 0.30).
-ANIMATE — True/False (увімкнути/вимкнути покрокову анімацію).
-PAUSE — пауза між сегментами (сек., напр. 0.01).

### Висновок

Реалізація дерева Піфагора коректно демонструє рекурсивне розгалуження: на кожному рівні довжина гілок масштабується у `√2/2`, а напрям змінюється на ±45°.  
Додано автомасштаб крони ( ~80% висоти кадру ) та покрокову анімацію, що робить візуалізацію наочною і керованою.  
Практично: за рівнів 8–12 малюнок виглядає збалансовано; збільшення рівня експоненційно підвищує кількість сегментів і час відмалювання.  
Отже, завдання демонструє ключові ідеї рекурсії, геометричної прогресії та базових технік графічної оптимізації в `turtle`.



## Завдання 3: Алгоритми на графах — Алгоритм Дейкстри

## Опис
У цьому завданні реалізовано алгоритм **Дейкстри** для пошуку найкоротших шляхів у зваженому графі з використанням **бінарної купи** (`heapq`).  
Алгоритм дозволяє знайти мінімальні відстані від початкової вершини до всіх інших, а також відновити дерево найкоротших шляхів.

## Реалізовано
- Клас `Graph` для збереження структури графа.
- Метод `dijkstra(src)` — пошук найкоротших шляхів з вершини `src` за допомогою черги з пріоритетом (`heapq`).
- Метод `path(parent, src, dst)` — відновлення маршруту від `src` до `dst`.
- Функція `print_explained_distances` — друк результатів у двох форматах:
  - короткий рядок із дистанціями;
  - розгорнутий опис зі шляхом та сумою ваг (напр. `A→C→B = 2+1`).
- Функція `visualize` — побудова графа:
  - усі ребра (тонкі лінії),
  - дерево найкоротших шляхів (товстіші),
  - виділений маршрут `src → dst` (найтовстіший),
  - вершини з підписаними мінімальними відстанями.


### Ключові результати
- **Точність:** коректні відстані та шляхи на тестових графах
- **Масштабованість:** працює з великими графами завдяки `O((V+E) log V)`
- **Юзабіліті:** одразу видно маршрут і складові ваг (напр. `A→C→B = 2+1`)


### Складність
- Час: `O((V + E) log V)`  
- Пам’ять: `O(V + E)`

### Висновок 

Алгоритм Дейкстри з пріоритетною чергою (`heapq`) коректно знаходить найкоротші відстані від джерела до всіх вершин і дозволяє відновити маршрути через `parent`.  
Реалізація масштабується як `O((V+E) log V)` і підходить для великих розріджених графів; формат виводу робить шлях і внесок кожного ребра наочними.  
Обмеження: алгоритм коректний лише для **невід’ємних ваг**, для від’ємних ребер потрібні інші методи.



## Завдання 4: Візуалізація піраміди (бінарної купи)

### Реалізовано
- Побудова дерева з масиву-купи: `build_heap_tree(arr)` (діти `2i+1`, `2i+2`)
- Візуалізація на `networkx + matplotlib`: `add_edges`, `draw_tree`
- Фарбування вузлів **за рівнями**: `level_color_rule_factory(palette)`
- Акуратне закриття вікна (не блокує / без `KeyboardInterrupt`)
- Обробка порожньої купи (виводить повідомлення, не падає)

### Ключові результати
- **Наглядність:** чітка структура купи з позиціонуванням по шарах
- **Гнучкість:** легка зміна палітри/правил підсвітки (корінь, рівні, “новий” елемент)
- **Надійність:** безпечна робота при порожньому вхідному списку

### Висновок
Візуалізатор демонструє структуру бінарної купи та дозволяє інтуїтивно пояснювати операції з купою (heapify, вставка, шари/висота) завдяки кольоровому кодуванню рівнів.

## Завдання 5: Візуалізація обходів бінарного дерева (BFS/DFS, без рекурсії)

### Реалізовано
- **BFS (в ширину)** — ітеративно через **чергу** (`collections.deque`)
- **DFS (в глибину)** — ітеративно через **стек** (LIFO)
- Покрокова анімація обходу: на кожному кроці вузол отримує **унікальний hex-колір** з градієнта **від темного до світлого**
- Неблокуючий показ графіки (без потреби в `Ctrl+C`), фінальний кадр з автозакриттям
- Акуратна обробка порожнього дерева

### Основні функції
- `order_bfs_iter(root)` — повертає порядок відвідування вузлів BFS (черга)
- `order_dfs_iter(root)` — повертає порядок відвідування вузлів DFS (стек)
- `visualize_traversal(root, mode='bfs'|'dfs', pause, start, end, block_final=False)`  
  - `mode` — тип обходу  
  - `pause` — затримка між кадрами (сек)  
  - `start`, `end` — межі градієнта у **hex** (наприклад, `#0b3d91` → `#a6d8ff`)  
  - `block_final` — `False` для неблокуючого фінального кадру (за замовчуванням)

### Висновок

Ітеративні реалізації **BFS** (черга) та **DFS** (стек) без рекурсії коректно відтворюють порядок обходу. 
Покрокова візуалізація з градієнтом (від темного до світлого) робить процес інтуїтивним: колір кодує номер відвідування, що полегшує порівняння стратегій обходу. 
Рішення стабільно працює на різних розмірах дерев; неблокуюче відображення та параметри паузи/палітри підвищують зручність. 
Таким чином, завдання демонструє як алгоритмічні відмінності BFS/DFS, так і практичні прийоми візуалізації.

  
## Завдання 6: Жадібний алгоритм та динамічне програмування (вибір страв за бюджетом)


### Мета
Обрати набір страв із **максимальною сумарною калорійністю** при обмеженому бюджеті (модель **0/1 рюкзака** — кожну страву можна взяти не більше одного разу).

### Вхідні дані (приклад)
```python
items = {
  "pizza": {"cost": 50, "calories": 300},
  "hamburger": {"cost": 40, "calories": 250},
  "hot-dog": {"cost": 30, "calories": 200},
  "pepsi": {"cost": 10, "calories": 100},
  "cola": {"cost": 15, "calories": 220},
  "potato": {"cost": 25, "calories": 350}
}
```

### Реалізовано
- `greedy_algorithm(items, budget)` — **жадібний добір** за показником **calories/cost** (value density).  
  ✔ Працює швидко, але не гарантує оптимального результату, бо не робить замін і може недовикористати бюджет.  

- `dynamic_programming(items, budget)` — **оптимальне розв’язання задачі 0/1 knapsack** із відновленням набору.  
  ✔ Завжди знаходить максимальні калорії в межах бюджету.  

- **Додаткові стратегії вибору (tie-break)** застосовуються лише тоді, коли існує кілька наборів із однаковою кількістю калорій:  
  - `min_cost` — обирає варіант із **меншою сумарною вартістю**;  
  - `max_spend` — обирає варіант, який **більше витрачає бюджет**.  

### Підсумок експериментів (повна таблиця)

### Підсумок експериментів
| Бюджет | Набір Greedy                       | Вартість | Калорії | Набір DP (оптим.)                 | Вартість | Калорії | Коментар                     |
|--------|------------------------------------|----------|---------|-----------------------------------|----------|---------|------------------------------|
| 40     | ['cola', 'potato']                 | 40       | **570** | ['cola', 'potato']                | 40       | **570** | Однаково                     |
| 50     | ['cola', 'potato','pepsi']         | 50       | **670** | ['pepsi','cola','potato']         | 50       | **670** | Однаково                     |
| 65     | ['cola','potato','pepsi']          | 50       | **670** | ['pepsi','cola','potato']         | 50       | **670** | Однаково (витрачено < бюджету)|
| 75     | ['cola','potato','pepsi']          | 50       | **670** | ['hot-dog','cola','potato']       | 70       | **770** | DP кращий (+100 ккал)        |
| 90     | ['cola','potato','pepsi','hot-dog']| 80       | **870** | ['hamburger','pepsi','cola','potato'] | 90   | **920** | DP кращий (+50 ккал, +витрачений бюджет) |

### Висновок
Greedy швидкий, але не завжди оптимальний (недовикористовує бюджет або втрачає калорії). 
**DP** (динамічне програмування) завжди знаходить найкращий набір. Наприклад, при бюджеті **75** DP  дає **770 ккал** тоді як Greedy лише **670 ккал**.

## Завдання 7. Метод Монте-Карло для двох кубиків

### Мета
Змоделювати k кидків двох ігрових кубиків, порахувати емпіричні ймовірності сум (2..12) та порівняти їх з аналітичними.

### Методика
- Виконано N = 1 000 000 симуляцій кидків двох d6 (рівноймовірні 1..6).
- Для кожного кидка обчислювалась сума S = d1 + d2.
- Підраховано частоти появ S і перетворено в ймовірності `p̂(S)`.
- Побудовано графік: стовпчики — Монте-Карло, лінія — аналітика.
- Додатково пораховано MAE і χ² для оцінки узгодженості.

### Аналітичні значення
Кількість комбінацій для суми S: `count(S) = min(S-1, 13-S)`; усього 36 комбінацій.  
Ймовірність: `p(S) = count(S)/36`.

### Результати (приклад)
| Сума | Монте-Карло | Аналітика | Δ абс. |
|-----:|------------:|----------:|------:|
| 2 | 2.77% | 2.78% | 0.01% |
| 3 | 5.57% | 5.56% | 0.01% |
| 4 | 8.36% | 8.33% | 0.03% |
| 5 | 11.15% | 11.11% | 0.04% |
| 6 | 13.88% | 13.89% | 0.01% |
| 7 | 16.66% | 16.67% | 0.01% |
| 8 | 13.86% | 13.89% | 0.03% |
| 9 | 11.10% | 11.11% | 0.01% |
| 10 | 8.34% | 8.33% | 0.01% |
| 11 | 5.54% | 5.56% | 0.02% |
| 12 | 2.77% | 2.78% | 0.01% |

**MAE:** ≈ 0.02% &nbsp;&nbsp; **χ² (df=10):** ≈ 2–6 (залежить від N) — що свідчить про хорошу узгодженість з теорією.

### Висновки 

- **Коректність.** Емпіричні ймовірності, отримані методом Монте-Карло, збігаються з аналітичними у межах статистичної похибки. Для N ≥ 100 000 середня абсолютна похибка (MAE) зазвичай < 0.1%.
- **Розподіл.** Найімовірніша сума — **7** (~16.7%); найрідші — **2** та **12** (~2.8%), що відповідає теорії.
- **Статистична перевірка.** Значення χ² (df=10) для типових запусків з N ≥ 100 000 зазвичай **менше** критичного 18.31 (α=0.05), тож немає підстав відхиляти гіпотезу про відповідність емпіричного розподілу аналітичному.


## Вимоги

- Python **3.10+**
- `matplotlib == 3.10.6` (візуалізації для завдань 4–5, 7)
- `numpy == 2.3.3` (залежність для `matplotlib`)
- `networkx >= 3.2, < 4` (дерева/графи для завдань 4–5)

## Встановлення залежностей

```bash
# Створення віртуального оточення
python -m venv .venv
```
```bash
# Активувати оточення
macOS / Linux:
source .venv/bin/activate
Windows (PowerShell):
.venv\Scripts\Activate.ps1
Windows (cmd):
.venv\Scripts\activate.bat
```
```bash
# Створіть файл requirements.txt з вмістом:
matplotlib==3.10.6
numpy==2.3.3
networkx>=3.2,<4
```
```bash
# Встановити всі залежності
pip install -r requirements.txt
```

## Запуск завдань
- python task1.py   # однозв’язний список
- python task2.py   # дерево Піфагора (turtle)
- python task3.py   # Дейкстра
- python task4.py   # візуалізація бінарної купи
- python task5.py   # візуалізація BFS/DFS
- python task6.py   # жадібний + DP
- python task7.py   # Монте-Карло для двох кубиків
